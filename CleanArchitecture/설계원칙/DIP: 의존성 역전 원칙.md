# DIP: 의존성 역전 원칙



### 유연성이 극대화된 시스템이란

* 소스코드 의존성이 추상에 의존하고 구체에는 의존하지 않는 시스템
* 변동성이 큰 구체적인 요소에 의존을 피한다(자주 변경될 수 밖에 없는 요소들)

### 안정된 추상화

##### 인터페이스는 구현체보다 변동성이 낮다

##### 인터페이스의 변동성을 낮추는 것이 소프트웨어 설계의 기본이다.

##### 실천법

* 변동성이 큰 구체 클래스를 참조하지 말라(대신 추상 인터페이스를 참조해라)
* 변동성이 큰 구체 클래스로부터 파생하지 말라
* 구체 함수를 오버라이드 하지 말라
  -> 대체로 구체 함수는 소스코드 의존성이 필요하다. 추상메서도를 선언하고 각자 용도에 맞게 구현한다
* 구체적이며 변동성이 크면 절대로 언급하지 말라

### 팩토리

##### 변동성이 큰 구체클래스의 참조를 피하기 위해 팩토리를 사용한다

![img](https://k.kakaocdn.net/dn/6XEQ7/btrgbmULxqW/7uCjFePMPrtcwrGm9XIh4k/img.png)

* Application은 Service 인터페이스를 통해서 ConcreteImpl를 사용한다. 이를 위해서 어떻게든 Application에서 ConcreteImpl 생성이 필요하다.
* ConcreteImpl에 대해 코드 의존성을 만들지 않으면서 그 목적을 이루기 위해 ServiceFactory인터페이스의 makeSvc 함수를 사용해 객체를 생성한다.
* ServiceFactory는 ServiceFactoryImpl을 통해 구현되고 makeSvc에서 ConcreteImpl의 객체를 생성하여 Service타입으로 반환해준다.
* 곡선은 추상컴포넌트와 구체컴포넌트로 나누고있다.
* 소스 코드의 의존성의 화살은 추상적인 쪽으로 향한다.(의존성과 반대 방향으로 흐름 => 의존성 역전)
* 구체적인 의존성이 하나 있다(ServiceFactoryImpl 구체클래스가 ConcreteImpl 구체클래스에 의존한다)
  -> DIP 위배를 모두 없앨 수는 없다. 하지만 DIP를 위배하는 클래스들은 적은 수 의 구체 컴포넌트 내부로 모을 수 있고, 이를 통해 시스템의 나머지 부분과 분리할 수 있다.
* 대다수의 시스템은 이러한 구체 컴포넌트를 최소한 하나는 포함할 것이다.



### 결론

* DIP는 아키텍처 다이어그램에서 가장 눈에 드러나는 원칙이다.



